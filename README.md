This is the classic MIPS R3000 pipeline processor implemented in Verilog. Originally, the code was planned to be minimal, handling hassles or data races as many as possible, but is not meant to `catch` all possibilities leading to bad fortune. However, under the great testing pressure of our school, many detections and bugfixes took place and the code became INCREDIBLY stable within the range of instructions it supports. 

A brief introduction to the setting of our course design will surely help you understand what this piece of code achieved, what are its limitations and how you can utilize it.

In the first place, the course carries out in `PROJECT X` form, where `X` ranges from 0 to 8. For details of each project, please see the directory pdf. Projects 0 to 3 primarily focused on drawing circuit diagrams using software named `Logisim`` (logical circuit simulation) which was quite out of date, as well as writing short programs in the MIPS assembly. From Project 4 on, we revolved around implementing CPU with more and more complicated techniques. Project 4 's main key is a single-period CPU which executes each instruction in one clock tick. Project 5 evolved to designing processors using pipelines to improve the throughput. Project 6 adds multiplication and division with some byte-wise addressing instructions on top of Project 5. In Project 7 we started to support exceptions and interrupts, while the last project gave us a chance to burn the soft core onto an integrated circuit.

The author of this repo found his place in ONLY Project 5, which means the code ONLY supports a reduced set of MIPS R3000 instructions without CP0 and other interruption facilities. From this perspective, the code seems to appear in a non-completed state. However, the main point here is to demonstrate fundamentally how the pipeline works and how to solve hazards and data races with stalls and bypasses, 2 basic techniques introduced in most undergraduate textbooks. As an effort towards good modularity, the code divided functionalities into Verilog modules, making it easier to understand.

You can also find many other materials in this field in my following uploading, including textbooks, example code with docs, instruction set specifications (in both English and Chinese), and most importantly, the test data, which generally comes in 3 files: a .txt hex code version for input, a .asm assembly version for debug ease and a .out for correct output to check against. What's more, an enhanced Mars is also provided which greatly reduces human power in terms of regression test and bug-fixing. It prints the effect of each executed instruction in the console. Another debugging tool is an inspect module that produces a time-space diagram of the execution process happening inside the CPU. One can look closely at the diagram to reveal some possible RAW data races to see whether bugs arose from failing to handle them well.
